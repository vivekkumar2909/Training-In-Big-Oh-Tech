import java.time.Duration;

public class CalculatePriceBasedOnHour implements PriceStrategy {
    @Override
    public double calculateFee(Duration d) {
        long dur = Math.max(1, (d.toMinutes() + 59) / 60);
        int ToPay = 0;

        if (dur >= 1) {
            ToPay += 4;
        }
        if (dur >= 2) {
            ToPay += 3.5;
        }
        if (dur >= 3) {
            ToPay += 3.5;
        }
        if (dur > 3) {
            ToPay += (dur - 3) * 2.5;
        }
        return ToPay;
    }
}
public class Entry {
    final ParkingLot lot;
    final String id;

    public Entry(ParkingLot lot, String id) {
        this.id = id;
        this.lot = lot;
    }

}
import java.util.*;

public class ParkingFloor {
    private int numbers;

    final List<ParkingSpot> spots = new ArrayList();

    public ParkingFloor(int numbers) {
        this.numbers = numbers;
    }

    public void addSpots(ParkingSpot spot) {
        spots.add(spot);
    }

    public ParkingSpot FindSpot(Vehicle veh) {
        for (ParkingSpot s : spots) {
            if (s.isFreeSpot() && s.isCanFitInParking(veh)) {
                return s;
            }
        }

        return null;
    }

    public void showFreeSpots() {
        System.out.println("Floor " + numbers + " free spots:");
        for (ParkingSpot s : spots) {
            if (s.isFreeSpot()) {
                System.out.println(" - * - " + s.getNo() + " (" + s.getTypeOfVehicle() + ") " + " - * - ");
            }
        }
    }

}
import java.util.*;
import java.time.*;

public class ParkingLot {
    private final String name;
    private final Map<Integer, ParkingFloor> floors = new HashMap<>();
    private final CalculatePriceBasedOnHour pricing;
    private final PaymentProcessor processor;

    public ParkingLot(String name, CalculatePriceBasedOnHour pricing, PaymentProcessor processor) {
        this.name = name;
        this.pricing = pricing;
        this.processor = processor;
    }

    public void addFloor(int num) {
        floors.put(num, new ParkingFloor(num));
    }

    public void addSpot(int floorNum, String id, String type) {
        floors.get(floorNum).addSpots(new ParkingSpot(id, type));
    }

    public ParkingFloor getFloor(int num) {
        return floors.get(num);
    }

    public double calculateFee(Ticket t) {
        return pricing.calculateFee(t.getDuration());
    }

    public void processPayment(double amount, String method) {
        processor.pay(amount, method);
    }

    public void showAvailableSpots() {
        System.out.println("\n--- Available Spots ---");
        for (ParkingFloor f : floors.values()) {
            f.showFreeSpots();
        }
        System.out.println("-----------------------\n");
    }
}public class ParkingSpot {
    String No;
    String typeOfVehicle;
    Vehicle vehicle; // Delegation Design Pattern Here;

    public ParkingSpot(String No, String typeOfVehicle) {
        this.typeOfVehicle = typeOfVehicle;
        this.No = No;
    }

    public boolean isFreeSpot() {
        return (vehicle == null);
    }

    boolean isCanFitInParking(Vehicle v) {
        if (typeOfVehicle.equals("COMPACT") && v.getTypeVehicle().equals("CAR")) {
            return true;
        } else if (typeOfVehicle.equals("ELECTRIC") && v.getTypeVehicle().equals("CAR")) {
            return true;
        } else if (typeOfVehicle.equals("LARGE") && v.getTypeVehicle().equals("TRUCK")) {
            return true;
        } else if (typeOfVehicle.equals("HANDICAPPED") && (v.getTypeVehicle().equals("CAR") || v.getTypeVehicle()
                .equals("TRUCK"))) {
            return true;
        } else if (typeOfVehicle.equals("SMALL") && v.getTypeVehicle().equals("MOTORCYCLES")) {
            return true;
        } else {
            return false;
        }
    }

    void park(Vehicle v) {
        this.vehicle = v;
    }

    void LeaveSpot() {
        this.vehicle = null;
    }

    String getNo() {
        return this.No;
    }

    String getTypeOfVehicle() {
        return this.typeOfVehicle;
    }

}
public interface PaymentMethod {

    void DoTransaction(double amount, String method);

}public interface PaymentMethod {

    void DoTransaction(double amount, String method);

}public class PaymentProcessor implements PaymentMethod {

    @Override
    public void DoTransaction(double amount, String method) {
        // TODO Auto-generated method stub

        System.out.println("Amount of : " + amount + " paid through " + method);

    }

}
import java.time.*;

public interface PriceStrategy {

    double calculateFee(Duration d);
}import java.time.*;

public class Ticket {

    String id;

    // Delegation
    Vehicle vehicle;

    LocalDateTime inTime;

    LocalDateTime outTime;

    boolean paid = false;

    public Ticket(String id, Vehicle veh) {
        this.id = id;
        this.vehicle = veh;

        this.inTime = LocalDateTime.now();
    }

    Vehicle getVehicle() {
        return vehicle;
    }

    LocalDateTime getInTime() {
        return inTime;
    }

    String getId() {
        return this.id;
    }

    public void markIsPaid() {
        this.paid = true;
        this.inTime = LocalDateTime.now();
    }

    boolean isPaid() {
        return paid;
    }

    public Duration geDuration() {
        LocalDateTime end = paid ? this.outTime : LocalDateTime.now();
        return Duration.between(inTime, end);
    }

    public Object getDuration() {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getDuration'");
    }

}
public class Vehicle {
    private final String typeOfVehicle;
    private final String numberOfVehicle;

    public Vehicle(String typeOfVehicle, String numberOfVehicle) {
        this.typeOfVehicle = typeOfVehicle;
        this.numberOfVehicle = numberOfVehicle;
    }

    public String getTypeVehicle() {
        return typeOfVehicle;
    }

    public String getNumber() {
        return numberOfVehicle;
    }
}
